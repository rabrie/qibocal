import random
import warnings

import numpy as np
import numpy.linalg as la

from scipy.linalg import expm
from scipy.linalg import qr
from scipy.optimize import root_scalar
from low_level_jit import local_basis,contract,MVE_lower,Mp_norm_lower



def transp(dim1,dim2): 
    """!
    Superoperator of a map that performs the transpose operation

    Parameters
    -------
    dim1 : int
        First dimension of the matrix to be transposed 
    dim2 : int
        Second dimension of the matrix to be transposed 

    Returns
    -------
    T: numpy array
        Transpose superoperator that turns a dim1xdim2 matrix into a dim2xdim1 matrix

    Notes:
        The projection is done with respect to the canonical metrik.
    """
    Id1 = np.eye(dim1)
    Id2 = np.eye(dim2)
    T = np.einsum('il,jk->ijkl',Id2,Id1).reshape(dim1*dim2,dim1*dim2)
    return T
            
def randpsd(n,normalized = "True"):
    """!

    Generate a random positive semidefinite square matrix

    Parameters
    -------
    n : int
        Number of matrix entries
    normalized : {Ture, False}, optional
        Controls if the output is trace normalized, defaults to "True"

    Returns
    -------
    mat: numpy array
        Random positive definite square matrix

    Notes:
        Eigenvalues are drawn uniformly from the interval [0,1);
        The basis is generated by diagonalizing a random hermitian matrix (see randHerm function).
    """
    dim = int(np.sqrt(n))
    H = randHerm(dim)
    U,_,_ = np.linalg.svd(H)
    evals = np.random.random_sample(dim)
    if normalized == "True":
        evals /= np.sum(evals)
    mat = np.dot(np.dot(U,np.diag(evals)),U.T.conj())
    mat = mat.reshape(-1)
    return mat

def randvec(n):
    """!

    Generate vector with real and imaginary part drawn from the normal distribution

    Parameters
    -------
    n : int
        Number of elements for the random vector

    Returns
    -------
    g: 1D numpy array
        Length n vector with complex entries whose real and imaginary part is independently drawn
        from the normal distribution with mean 0 and variance 1.

    """
    g = np.random.randn(n)+1j*np.random.randn(n) #randn(n) produces a random vector of length n with mean 0 and variance 1
    g = g/np.linalg.norm(g)
    return g

def randHerm(n):
    """!

    Generate random square hermitian matrix

    Parameters
    -------
    n : int
        Matrix dimension

    Returns
    -------
    G: 2D numpy array
        Random hermitian matrix normalized in spectral norm

    Notes: 
        First a matrix with random complex entries is generated (see randvec function).
        This matrix is then projected onto the space of hermitian matrices and normalized in spectral norm. 

    """
    G = randvec(n*n).reshape(n,n)
    G = (G+G.T.conj())/2
    G = G/np.linalg.norm(G, ord=2) #ord=2 gives the spectral norm
    return G

def randHermGS(d,r): 
    """!

    Generates random set of operators that are hermiticity preserving

    Parameters
    -------
    d : int
        Number of gates
    r : int
        Superoperator dimension of the gates given by the square of the physical dimension

    Returns
    -------
    X: 3D numpy array
        Array where random hermiticity preserving operators are stacked along the first axis. 

    Notes:
        The function randHerm is used to generate random hermitian Choi matrices, 
        whose indies are then rearanged to obtain random hermiticity preserving superoperators.

    """
    dim = int(np.sqrt(r))
    X = np.zeros((r,d,r),dtype = 'complex')
    for i in range(d):
        H = randHerm(r).reshape(dim,dim,dim,dim) 
        H = np.einsum('ijkl->jlik',H)
        X[:,i,:] =  H.reshape(r,r)
    return X

def randU(n,a=1):
    """!

    Generates random unitary from a random hermitian generator

    Parameters
    -------
    n : int
        Matrix dimension of the unitary
    a : float
        Parameter to control the norm of the hermitian generator

    Returns
    -------
    U: 2D numpy array
        Matrix exponential of random hermitian matrix times the imaginary unit. 

    """    
    return expm(1j*a*randHerm(n)).astype(np.complex128)

def randU_Haar(n):
    """!

    Return a Haar distributed random unitary

    Parameters
    -------
    n : int
        Matrix dimension of the unitary

    Returns
    -------
    U: 2D numpy array
        Random unitary matrix distributed according to the Haar measure.

    """
    Z = np.random.randn(n,n) + 1.0j * np.random.randn(n,n)
    [Q,R] = qr(Z)
    D = np.diag(np.diagonal(R) / np.abs(np.diagonal(R)))
    return np.dot(Q, D)

def randKrausSet(d,r,rK,a = 1):
    """!

    Generates random set of Kraus operators

    Parameters
    -------
    d : int
        Number of gates
    r : int
        Superoperator dimension of the gates given by the square of the physical dimension
    rK : int
        Number of Kraus operators per gate ("Kraus rank")
    a : float
        Parameter to control the norm of the hermitian generator and thereby how far the gates are from the identity

    Returns
    -------
    K: 4D numpy array
        Each subarray along the first axis contains a set of Kraus operators.
        The second axis enumerates Kraus operators for a gate specified by the first axis.

    Notes:
        Let pdim be the physical dimension. Then a set of Kraus operators is generated by taking the first pdim columns of 
        a random unitary of size rK*pdim. The random unitary is generated from a random hermitian matrix. 

    """
    pdim = int(np.sqrt(r))
    K = np.zeros((d,rK,pdim,pdim)).astype(np.complex128)
    for i in range(d):
        K[i,:,:,:] += randU(pdim*rK,a)[:,:pdim].reshape(rK,pdim,pdim)
    return K

def randKrausSet_Haar(d,r,rK):
    """!

    Generates random set of Kraus operators

    Parameters
    -------
    d : int
        Number of gates
    r : int
        Superoperator dimension of the gates given by the square of the physical dimension
    rK : int
        Number of Kraus operators per gate ("Kraus rank")

    Returns
    -------
    K: 4D numpy array
        Each subarray along the first axis contains a set of Kraus operators.
        The second axis enumerates Kraus operators for a gate specified by the first axis.

    Notes:
        Let pdim be the physical dimension. Then a set of Kraus operators is generated by taking the first pdim columns of 
        a random unitary of size rK*pdim. The random unitary is generated according the the Haar measure.

    """
    pdim = int(np.sqrt(r))
    K = np.zeros((d,rK,pdim,pdim)).astype(np.complex128)
    for i in range(d):
        K[i,:,:,:] += randU_Haar(pdim*rK)[:,:pdim].reshape(rK,pdim,pdim)
    return K

def random_gs(d,r,rK,n_povm):
    """!

    Generates a random gate using the Gaussian unitary ensemble, initial state and POVM

    Parameters
    -------
    d : int
        Number of gates
    r : int
        Superoperator dimension of the gates given by the square of the physical dimension
    rK : int
        Number of Kraus operators per gate ("Kraus rank")
    n_povm : int
        Number of POVM-Elements

    Returns
    -------
    K: 4D numpy array
        Each subarray along the first axis contains a set of Kraus operators.
        The second axis enumerates Kraus operators for a gate specified by the first axis.
    X: 3D numpy array
        Array where random CPT superoperators are stacked along the first axis. 

    Notes:
        The Kraus operators are generated from random unitaries, see function randKrausSet

    """
    K = randKrausSet(d,r,rK).copy()
    X = np.einsum('ijkl,ijnm -> iknlm', K, K.conj()).reshape(d,r,r) 
    rho = randpsd(r).copy()
    A = randKrausSet(1,r,n_povm)[0].conj()
    E = np.array([(A[i].T.conj()@A[i]).reshape(-1) for i in range(n_povm)]).copy()
    return K,X,E,rho

def random_gs_Haar(d,r,rK,n_povm):
    """!

    Generates a random gate set with gates from Haar random unitaries, initial state and POVM

    Parameters
    -------
    d : int
        Number of gates
    r : int
        Superoperator dimension of the gates given by the square of the physical dimension
    rK : int
        Number of Kraus operators per gate ("Kraus rank")
    n_povm : int
        Number of POVM-Elements

    Returns
    -------
    K: 4D numpy array
        Each subarray along the first axis contains a set of Kraus operators.
        The second axis enumerates Kraus operators for a gate specified by the first axis.
    X: 3D numpy array
        Array where random CPT superoperators are stacked along the first axis. 

    Notes:
        The Kraus operators are generated from Haar random unitaries, see function randKrausSet_Haar
    """
    K = randKrausSet_Haar(d,r,rK).copy()
    X = np.einsum('ijkl,ijnm -> iknlm', K, K.conj()).reshape(d,r,r) 
    rho = randpsd(r).copy()
    A = randKrausSet_Haar(1,r,n_povm)[0].conj()
    E = np.array([(A[i].T.conj()@A[i]).reshape(-1) for i in range(n_povm)]).copy()
    return K,X,E,rho

def basis(size, index):
    """!

    Creates standard basis vectors

    Parameters
    -------
    size : int
        Vector space dimension
    index : int
        Index of basis vector

    Returns
    -------
    vec: 1D numpy array
        Vector with entry 1 at position given by index and zeros elsewhere
    """
    vec = np.zeros(size)
    vec[index] = 1.0
    return vec

def depol(pdim,p): 
    """!

    Kraus representation of depolarizing channel

    Parameters
    -------
    pdim : int
        Physical dimension
    p : float
        Error probability

    Returns
    -------
    K_depol: 4D numpy array
        Each entry along the first axis contains a set of Kraus operators.
        The second axis enumerates Kraus operators for a gate specified by the first axis.

    Notes:
        The depolarizing channel is defined as L(rho) = (1-p)*rho + p/pdim*Id.
    """
    phi_plus = np.sum([np.kron(basis(pdim,i),basis(pdim,i)) for i in range(pdim)],axis = 0)
    choi_state = p/pdim*np.eye(pdim**2) + (1-p)*np.kron(phi_plus,phi_plus.reshape(pdim**2,1))
    K_depol = la.cholesky(choi_state)
    return K_depol.reshape(pdim,pdim,pdim**2).swapaxes(0,2)


def varassign(v,X,E,rho, argument): 
    """!

    Assigns input to specified gate set variables

    Parameters
    -------
    v : numpy array
        New set of variables
    X : numpy array
        Current gate estimate
    E : numpy array
        Current POVM estimate
    rho : numpy array
        Current initial state estimate
    argument : {"X", "E", "rho"}
        Which part of the gate set is updated

    Returns
    -------
    [.,.,.]: 3 element list
        List in the order [X,E,rho] where either X, E or rho is repaced by v, depending on the input to the "arguement" variable
    """
    if argument == "X" or argument == "K":
        return [v,E,rho]
    elif argument == "E":
        return [X,v,rho]
    elif argument == "rho":
        return [X,E,v]
    
def batch(y,J,bsize): 
    """!

    Returns random batch of sequences and corresponding measurements

    Parameters
    -------
    y : numpy array
        2D array of measurement outcomes for sequences in J; 
        Each column contains the outcome probabilities for a fixed sequence
    J : numpy array 
        2D array where each row contains the gate indices of a gate sequence
    bsize : int
        Size of the batch (number of sequences)

    Returns
    -------
    y_b : numpy array
        Randomly subsampled columns of y
    J_b : numpy array
        Randomly subsampled rows of J in accordance the the columns selected in y_b

    """
    if y.shape[1]<=bsize:
        return y,J
    if bsize < 1: #if batch size is given as ratio
        bsize = int(bsize*len(J)//1)
    batchmask = np.array([1] * bsize + [0] * (len(J)-bsize))
    np.random.shuffle(batchmask)
    J_b = J[batchmask == 1]
    y_b = y[:,batchmask == 1]
    return y_b, J_b
    
def F_avg_X(X,K): 
    """!

    Returns the average gate fidelity between two gates given by a superoperator and a set of Kraus operators

    Parameters
    -------
    X : 2D numpy array
        CPT superoperator of size (pysical dimension**2) x (pysical dimension **2)
    K : 3D numpy array 
        Array of Kraus operators with size (Kraus rank) x (pysical dimension) x (pysical dimension)

    Returns
    -------
    Fid : float
        Average gate fidelity

    Notes: 
    Not gauge optimization involved; Average gate fidelity is gauge dependent.

    """
    pdim = K.shape[2]
    d = K.shape[0]
    Fid_list = []
    for k in range(d):
        choi_inner_prod= np.einsum('imjl,pml,pij',X[k].reshape(pdim,pdim,pdim,pdim),K[k],K[k].conj())

        unitality_term = np.einsum('imkk,pml,pil',X[k].reshape(pdim,pdim,pdim,pdim),K[k],K[k].conj())
        Fid = (choi_inner_prod + unitality_term)/pdim/(pdim+1)
        Fid_list.append(Fid)
    return np.average(np.real(Fid_list)), np.real(Fid_list)
    
def MVE(X_true,E_true,rho_true,X,E,rho,d,l,n_povm,samples = 10000): 
    """!

    Mean varation error between the outputs of two gate sets on random sequences

    Parameters
    -------
    X_true : numpy array
        Target gates
    E_true : numpy array
        Target POVM
    rho_true : numpy array
        Target initial state
    X : numpy array
        Current gate estimate
    E : numpy array
        Current POVM estimate
    rho : numpy array
        Current initial state estimate
    d : int
        Number of different gates in the gate set
    l : int
        Length of the test sequences
    n_povm : int
        Number of POVM elements
    samples : int
        Number of random gate sequences over which the mean variation error is computed

    Returns
    -------
    MVE : float
        Mean varaition error

    Notes:
        Sequences are drawn without replacement from initally d**l possibilities. 
        For each sequence the total variation error of the two probability distribution over the POVM elements is computed. 
        Afterwards the meean over these total variation errors is returned.

    """
    if samples == 'all' or np.log(samples)/np.log(d) > l:
        J = np.random.randint(0,d,l*d**l).reshape(d**l,l)
    else:
        J = np.random.randint(0,d,l*samples).reshape(samples,l)
    return MVE_lower(X_true,E_true,rho_true,X,E,rho,J,d,l,n_povm)

def Mp_norm(X_true,E_true,rho_true,X,E,rho,d,l,n_povm,p,samples = 10000): 
    """!

    Mean of the p-norm deviation between the outputs of two gate sets on random sequences

    Parameters
    -------
    X_true : numpy array
        Target gates
    E_true : numpy array
        Target POVM
    rho_true : numpy array
        Target initial state
    X : numpy array
        Current gate estimate
    E : numpy array
        Current POVM estimate
    rho : numpy array
        Current initial state estimate
    d : int
        Number of different gates in the gate set
    l : int
        Length of the test sequences
    n_povm : int
        Number of POVM elements
    p : int
        Defines the l_p - norm that is used to compare probability distributions
    samples : int
        Number of random gate sequences over which the mean variation error is computed

    Returns
    -------
    MPE : float
        Mean l_p - norm error

    Notes:
        Sequences are drawn without replacement from initally d**l possibilities. 
        For each sequence the l_p - norm error of the two probability distribution over the POVM elements is computed. 
        Afterwards the meean over these total variation errors is returned.

    """
    if samples == 'all' or np.log(samples)/np.log(d) > l:
        J = np.random.randint(0,d,l*d**l).reshape(d**l,l)
    else:
        J = np.random.randint(0,d,l*samples).reshape(samples,l)
    return Mp_norm_lower(X_true,E_true,rho_true,X,E,rho,J,d,l,n_povm,p)

def Kraus_rep(X,d,pdim,rK): 
    """!

    Compute the Kraus representations for all gates in the gate set

    Parameters
    -------
    X : numpy array
        Current gate estimate
    d : int
        Number of gates
    pdim : int
        Physical dimension
    rK : int
        Target Kraus rank

    Returns
    -------
    K: 4D numpy array
        Each subarray along the first axis contains a set of Kraus operators.
        The second axis enumerates Kraus operators for a gate specified by the first axis.

    Notes:
        The Kraus representation is obtained from a singular value decomposition of the Choi matrix.
        If parameter rK is smaller than the true rank of the Choi matrix, a rank rK approximation is used. 
    """
    X_choi = X.reshape(d,pdim,pdim,pdim,pdim)
    X_choi = np.einsum('ijklm->iljmk',X_choi).reshape(d,pdim**2,pdim**2)
    K = np.zeros((d,rK,pdim,pdim)).astype(np.complex128)
    for i in range(d):
        w,v = la.eigh(X_choi[i])
        if np.min(w)<-1e-12:
            raise ValueError('Choi Matrix is not positive definite within tolerance 1e-12')
        K[i] = np.einsum('ijk->kji',(v[:,-rK:]@np.diag(np.sqrt(np.abs(w[-rK:])))).reshape(pdim,pdim,rK))
    return np.array(K)


def sampled_measurements(y,n):
    """!

    Compute finite sample estimates of input probabilities

    Parameters
    -------
    y : numpy array
        2D array of measurement outcomes for different sequences; 
        Each column contains the outcome probabilities for a fixed sequence
    n : Number of samples for each experiment


    Returns
    -------
    y_sampled : numpy array
        2D array of sampled measurement outcomes for different sequences; 
        Each column contains the sampled outcome probabilities for a fixed sequence

    Notes:
        The entries of each column of y form a probability distribution. From this distribution n random samples are drawn 
        which give estimates for the initial probabilities. This simulates finite sample size data.
    """
    n_povm,m = y.shape
    if any(y.reshape(-1)>1) or any(y.reshape(-1)<0):
        y_new = np.maximum(np.minimum(y,1),0)
        if np.sum(np.abs(y_new-y)) > 1e-6:
            warnings.warn("Warning: Probabilities capped to interval [0,1], l1-difference to input:%f"%np.sum(np.abs(y_new-y)))
        y = y_new
    rng = np.random.default_rng()
    y_sampled = np.zeros(y.shape)
    for i in range(m):
        y_sampled[:,i] = rng.multinomial(n, [y[o,i] for o in range(n_povm)])/n
    return y_sampled


def random_len_seq(d,max_l,N):
    """!

    Generate gate sequence instructions which contain sequences of different lengths

    Parameters
    -------
    d : int
        Number of gates
    max_l : int
        Maximum sequence length
    N : int
        Number of random sequences


    Returns
    -------
    J : numpy array 
        2D array where each row contains the gate indices of a gate sequence

    Notes:
        First generates the N/2 shortest sequences and then distributes the remaining number of seuqences equally among 
        the remaining sequences lengths up to max_l. 
    """
    cutoff = np.floor(np.log((d-1)*N/2/d+1)/np.log(d))
    seq_lengths = np.random.randint(cutoff+1,max_l+1,int(N-d*(d**cutoff-1)/(d-1)))
    J = []
    for l in range(1,int(cutoff)+1):
        J_indices = np.arange(d**l)
        for ind in J_indices:
            j_curr = local_basis(ind,d,l)
            J.append(list(np.pad(j_curr,(0,max_l-len(j_curr)),'constant',constant_values=-1)))
    for l in seq_lengths:
        j_curr = np.random.randint(1,d,l)
        J.append(list(np.pad(j_curr,(0,max_l-len(j_curr)),'constant',constant_values=-1)))
    return np.array(J)


def generate_fids(d,l,m_f):
    """!

    Generate random fiducial sequencecs

    Parameters
    -------
    d : int
        Number of gates
    l : int
        Total sequence length
    m_f : int
        Number of random fiducial sequences


    Returns
    -------
    J_fid : numpy array 
        Sequence list of only the fiducial sequences
    J_fid2 : numpy array 
        Sequence list for all combinations of two concatenated fiducial sequences
    J_meas : numpy array 
        Sequence list for all combinations of fiducials seuqneces with a gate in between: fiducial1 -- gate -- fiducial2

    """
    fid_len = (l-1)//2
    fid = random.sample(range(d**fid_len), m_f).copy()
    J_fid = [list(local_basis(ind,d,fid_len)) for ind in fid]
    J_fid2 = np.array([seqL+seqR for seqL in J_fid for seqR in J_fid])
    J_meas = np.zeros((d,m_f**2,l), dtype = 'int')
    for k in range(d):
        J_meas[k] = np.array([seqL+[k]+seqR for seqL in J_fid for seqR in J_fid])
    return np.array(J_fid), J_fid2, J_meas

    
def is_positive(X,E,rho):
    """!

    Prints the results for checks whether a gate set is physical. This includes all positivity and normalization constraints.

    Parameters
    -------
    X : numpy array
        Gate set
    E : numpy array
        POVM
    rho : numpy array
        Initial state

    Returns
    -------
    -

    """
    d,r,_ = X.shape
    pdim = int(np.sqrt(r))
    n_povm = E.shape[0]
    
    X_choi = X.reshape(d,pdim,pdim,pdim,pdim)
    X_choi = np.einsum('ijklm->iljmk',X_choi).reshape(d,r,r)
    
    eigvals = np.array([la.eigvals(X_choi[i]) for i in range(d)])
    partial_traces = np.einsum('aiikl -> akl', X.reshape(d,pdim,pdim,pdim,pdim))
    povm_eigvals = np.array([la.eigvals(E[i].reshape(pdim,pdim)) for i in range(n_povm)])
    if np.any(np.imag(eigvals.reshape(-1) > 1e-10)):
        print('Gates are not all hermitian.')
    else:
        for i in range(d):
            print('Gate %i positive:'%i, np.all(eigvals[i,:] > - 1e-10))
            print('Gate %i trace preserving:'%i, la.norm(partial_traces[i]-np.eye(pdim)) < 1e-10)
    print('Initial state positive:', np.all(la.eigvals(rho.reshape(pdim,pdim)) > - 1e-10))
    print('Initial state normalization:', np.trace(rho.reshape(pdim,pdim)))
    print('POVM valid:', np.all([la.norm(np.sum(E,axis = 0).reshape(pdim,pdim) - np.eye(pdim))<1e-10, np.all(povm_eigvals.reshape(-1) > - 1e-10)]))
    return